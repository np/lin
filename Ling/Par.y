-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Ling.Par
  ( happyError
  , myLexer
  , pProgram
  , pDec
  , pAssertion
  , pConName
  , pListConName
  , pOptSig
  , pListDec
  , pVarDec
  , pChanDec
  , pListChanDec
  , pBranch
  , pListBranch
  , pLiteral
  , pATerm
  , pListATerm
  , pTerm3
  , pTerm2
  , pTerm1
  , pTerm
  , pProc1
  , pProc
  , pListProc
  , pReplKind
  , pWithIndex
  , pAct
  , pASession
  , pSplit
  , pOptAs
  , pTopCPatt
  , pCPatt
  , pListCPatt
  , pOptSession
  , pRSession
  , pListRSession
  , pOptRepl
  , pCSession
  , pNewSig
  , pNewPatt
  , pNewAlloc
  ) where

import Prelude

import qualified Ling.Abs
import Ling.Lex

}

%name pProgram Program
%name pDec Dec
%name pAssertion Assertion
%name pConName ConName
%name pListConName ListConName
%name pOptSig OptSig
%name pListDec ListDec
%name pVarDec VarDec
%name pChanDec ChanDec
%name pListChanDec ListChanDec
%name pBranch Branch
%name pListBranch ListBranch
%name pLiteral Literal
%name pATerm ATerm
%name pListATerm ListATerm
%name pTerm3 Term3
%name pTerm2 Term2
%name pTerm1 Term1
%name pTerm Term
%name pProc1 Proc1
%name pProc Proc
%name pListProc ListProc
%name pReplKind ReplKind
%name pWithIndex WithIndex
%name pAct Act
%name pASession ASession
%name pSplit Split
%name pOptAs OptAs
%name pTopCPatt TopCPatt
%name pCPatt CPatt
%name pListCPatt ListCPatt
%name pOptSession OptSession
%name pRSession RSession
%name pListRSession ListRSession
%name pOptRepl OptRepl
%name pCSession CSession
%name pNewSig NewSig
%name pNewPatt NewPatt
%name pNewAlloc NewAlloc
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'        { PT _ (TS _ 1)       }
  '('        { PT _ (TS _ 2)       }
  ')'        { PT _ (TS _ 3)       }
  '**'       { PT _ (TS _ 4)       }
  ','        { PT _ (TS _ 5)       }
  '->'       { PT _ (TS _ 6)       }
  '-o'       { PT _ (TS _ 7)       }
  '.'        { PT _ (TS _ 8)       }
  ':'        { PT _ (TS _ 9)       }
  ':*'       { PT _ (TS _ 10)      }
  ':]'       { PT _ (TS _ 11)      }
  ';'        { PT _ (TS _ 12)      }
  '<'        { PT _ (TS _ 13)      }
  '<-'       { PT _ (TS _ 14)      }
  '<='       { PT _ (TS _ 15)      }
  '='        { PT _ (TS _ 16)      }
  '>'        { PT _ (TS _ 17)      }
  '?'        { PT _ (TS _ 18)      }
  '@'        { PT _ (TS _ 19)      }
  'Type'     { PT _ (TS _ 20)      }
  '['        { PT _ (TS _ 21)      }
  '[:'       { PT _ (TS _ 22)      }
  '\\'       { PT _ (TS _ 23)      }
  ']'        { PT _ (TS _ 24)      }
  '^'        { PT _ (TS _ 25)      }
  '`'        { PT _ (TS _ 26)      }
  'as'       { PT _ (TS _ 27)      }
  'assert'   { PT _ (TS _ 28)      }
  'case'     { PT _ (TS _ 29)      }
  'data'     { PT _ (TS _ 30)      }
  'end'      { PT _ (TS _ 31)      }
  'fwd'      { PT _ (TS _ 32)      }
  'in'       { PT _ (TS _ 33)      }
  'let'      { PT _ (TS _ 34)      }
  'new'      { PT _ (TS _ 35)      }
  'new/'     { PT _ (TS _ 36)      }
  'of'       { PT _ (TS _ 37)      }
  'parallel' { PT _ (TS _ 38)      }
  'proc'     { PT _ (TS _ 39)      }
  'recv'     { PT _ (TS _ 40)      }
  'send'     { PT _ (TS _ 41)      }
  'sequence' { PT _ (TS _ 42)      }
  'split'    { PT _ (TS _ 43)      }
  'with'     { PT _ (TS _ 44)      }
  '{'        { PT _ (TS _ 45)      }
  '|'        { PT _ (TS _ 46)      }
  '}'        { PT _ (TS _ 47)      }
  '~'        { PT _ (TS _ 48)      }
  L_charac   { PT _ (TC $$)        }
  L_doubl    { PT _ (TD $$)        }
  L_integ    { PT _ (TI $$)        }
  L_quoted   { PT _ (TL $$)        }
  L_Name     { PT _ (T_Name $$)    }
  L_NewName  { PT _ (T_NewName $$) }
  L_OpName   { PT _ (T_OpName $$)  }

%%

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Name :: { Ling.Abs.Name }
Name  : L_Name { Ling.Abs.Name $1 }

NewName :: { Ling.Abs.NewName }
NewName  : L_NewName { Ling.Abs.NewName $1 }

OpName :: { Ling.Abs.OpName }
OpName  : L_OpName { Ling.Abs.OpName $1 }

Program :: { Ling.Abs.Program }
Program : ListDec { Ling.Abs.Prg $1 }

Dec :: { Ling.Abs.Dec }
Dec
  : Name OptSig '=' Term { Ling.Abs.DDef $1 $2 $4 }
  | Name ':' Term { Ling.Abs.DSig $1 $3 }
  | 'data' Name '=' ListConName { Ling.Abs.DDat $2 $4 }
  | 'assert' Assertion { Ling.Abs.DAsr $2 }

Assertion :: { Ling.Abs.Assertion }
Assertion : Term '=' Term OptSig { Ling.Abs.AEq $1 $3 $4 }

ConName :: { Ling.Abs.ConName }
ConName : '`' Name { Ling.Abs.CN $2 }

ListConName :: { [Ling.Abs.ConName] }
ListConName
  : {- empty -} { [] }
  | ConName { (:[]) $1 }
  | ConName '|' ListConName { (:) $1 $3 }

OptSig :: { Ling.Abs.OptSig }
OptSig
  : {- empty -} { Ling.Abs.NoSig } | ':' Term { Ling.Abs.SoSig $2 }

ListDec :: { [Ling.Abs.Dec] }
ListDec
  : {- empty -} { [] }
  | Dec { (:[]) $1 }
  | Dec ',' ListDec { (:) $1 $3 }

VarDec :: { Ling.Abs.VarDec }
VarDec : '(' Name OptSig ')' { Ling.Abs.VD $2 $3 }

ChanDec :: { Ling.Abs.ChanDec }
ChanDec : Name OptRepl OptSession { Ling.Abs.CD $1 $2 $3 }

ListChanDec :: { [Ling.Abs.ChanDec] }
ListChanDec
  : {- empty -} { [] }
  | ChanDec { (:[]) $1 }
  | ChanDec ',' ListChanDec { (:) $1 $3 }

Branch :: { Ling.Abs.Branch }
Branch : ConName '->' Term { Ling.Abs.Br $1 $3 }

ListBranch :: { [Ling.Abs.Branch] }
ListBranch
  : {- empty -} { [] }
  | Branch { (:[]) $1 }
  | Branch ',' ListBranch { (:) $1 $3 }

Literal :: { Ling.Abs.Literal }
Literal
  : Integer { Ling.Abs.LInteger $1 }
  | Double { Ling.Abs.LDouble $1 }
  | String { Ling.Abs.LString $1 }
  | Char { Ling.Abs.LChar $1 }

ATerm :: { Ling.Abs.ATerm }
ATerm
  : Name { Ling.Abs.Var $1 }
  | OpName { Ling.Abs.Op $1 }
  | Literal { Ling.Abs.Lit $1 }
  | ConName { Ling.Abs.Con $1 }
  | 'Type' { Ling.Abs.TTyp }
  | '<' ListRSession '>' { Ling.Abs.TProto $2 }
  | '(' Term OptSig ')' { Ling.Abs.Paren $2 $3 }
  | 'end' { Ling.Abs.End }
  | '{' ListRSession '}' { Ling.Abs.Par $2 }
  | '[' ListRSession ']' { Ling.Abs.Ten $2 }
  | '[:' ListRSession ':]' { Ling.Abs.Seq $2 }

ListATerm :: { [Ling.Abs.ATerm] }
ListATerm : {- empty -} { [] } | ATerm ListATerm { (:) $1 $2 }

Term3 :: { Ling.Abs.Term }
Term3 : ATerm ListATerm { Ling.Abs.RawApp $1 $2 }

Term2 :: { Ling.Abs.Term }
Term2
  : 'case' Term 'of' '{' ListBranch '}' { Ling.Abs.Case $2 $5 }
  | '!' Term3 CSession { Ling.Abs.Snd $2 $3 }
  | '?' Term3 CSession { Ling.Abs.Rcv $2 $3 }
  | '~' Term2 { Ling.Abs.Dual $2 }
  | '<-' Name { Ling.Abs.TRecv $2 }
  | Term3 { $1 }

Term1 :: { Ling.Abs.Term }
Term1
  : Term2 '-o' Term1 { Ling.Abs.Loli $1 $3 }
  | Term2 '->' Term1 { Ling.Abs.TFun $1 $3 }
  | Term2 '**' Term1 { Ling.Abs.TSig $1 $3 }
  | 'let' Name OptSig '=' Term 'in' Term { Ling.Abs.Let $2 $3 $5 $7 }
  | Term2 { $1 }

Term :: { Ling.Abs.Term }
Term
  : '\\' Term2 '->' Term { Ling.Abs.Lam $2 $4 }
  | 'proc' '(' ListChanDec ')' Proc { Ling.Abs.TProc $3 $5 }
  | Term1 { $1 }

Proc1 :: { Ling.Abs.Proc }
Proc1
  : Act { Ling.Abs.PAct $1 }
  | '(' ListProc ')' { Ling.Abs.PPrll $2 }
  | ReplKind '^' ATerm WithIndex Proc1 { Ling.Abs.PRepl $1 $3 $4 $5 }

Proc :: { Ling.Abs.Proc }
Proc
  : Proc1 Proc { Ling.Abs.PNxt $1 $2 }
  | Proc1 '.' Proc { Ling.Abs.PDot $1 $3 }
  | Proc1 ';' Proc { Ling.Abs.PSem $1 $3 }
  | Proc1 { $1 }

ListProc :: { [Ling.Abs.Proc] }
ListProc
  : {- empty -} { [] }
  | Proc { (:[]) $1 }
  | Proc '|' ListProc { (:) $1 $3 }

ReplKind :: { Ling.Abs.ReplKind }
ReplKind
  : 'sequence' { Ling.Abs.ReplSeq } | 'parallel' { Ling.Abs.ReplPar }

WithIndex :: { Ling.Abs.WithIndex }
WithIndex
  : {- empty -} { Ling.Abs.NoIndex }
  | 'with' Name { Ling.Abs.SoIndex $2 }

Act :: { Ling.Abs.Act }
Act
  : NewAlloc { Ling.Abs.Nu $1 }
  | Split { Ling.Abs.Split $1 }
  | 'send' Name ATerm { Ling.Abs.Send $2 $3 }
  | Name OptSession '<-' ATerm { Ling.Abs.NewSend $1 $2 $4 }
  | 'recv' Name VarDec { Ling.Abs.Recv $2 $3 }
  | 'let' Name OptSig '<-' Name { Ling.Abs.NewRecv $2 $3 $5 }
  | 'let' Name OptSig '<=' ATerm { Ling.Abs.LetRecv $2 $3 $5 }
  | 'fwd' ASession '(' ListChanDec ')' { Ling.Abs.Ax $2 $4 }
  | 'fwd' Integer ASession Name { Ling.Abs.SplitAx $2 $3 $4 }
  | '@' ATerm TopCPatt { Ling.Abs.At $2 $3 }
  | 'let' Name OptSig '=' ATerm { Ling.Abs.LetA $2 $3 $5 }

ASession :: { Ling.Abs.ASession }
ASession : ATerm { Ling.Abs.AS $1 }

Split :: { Ling.Abs.Split }
Split
  : 'split' Name OptAs CPatt { Ling.Abs.PatSplit $2 $3 $4 }
  | Name '{' ListChanDec '}' { Ling.Abs.ParSplit $1 $3 }
  | Name '[' ListChanDec ']' { Ling.Abs.TenSplit $1 $3 }
  | Name '[:' ListChanDec ':]' { Ling.Abs.SeqSplit $1 $3 }

OptAs :: { Ling.Abs.OptAs }
OptAs : {- empty -} { Ling.Abs.NoAs } | 'as' { Ling.Abs.SoAs }

TopCPatt :: { Ling.Abs.TopCPatt }
TopCPatt
  : '(' ListChanDec ')' { Ling.Abs.OldTopPatt $2 }
  | '{' ListCPatt '}' { Ling.Abs.ParTopPatt $2 }
  | '[' ListCPatt ']' { Ling.Abs.TenTopPatt $2 }
  | '[:' ListCPatt ':]' { Ling.Abs.SeqTopPatt $2 }

CPatt :: { Ling.Abs.CPatt }
CPatt
  : ChanDec { Ling.Abs.ChaPatt $1 }
  | '{' ListCPatt '}' { Ling.Abs.ParPatt $2 }
  | '[' ListCPatt ']' { Ling.Abs.TenPatt $2 }
  | '[:' ListCPatt ':]' { Ling.Abs.SeqPatt $2 }

ListCPatt :: { [Ling.Abs.CPatt] }
ListCPatt
  : {- empty -} { [] }
  | CPatt { (:[]) $1 }
  | CPatt ',' ListCPatt { (:) $1 $3 }

OptSession :: { Ling.Abs.OptSession }
OptSession
  : {- empty -} { Ling.Abs.NoSession }
  | ':' RSession { Ling.Abs.SoSession $2 }

RSession :: { Ling.Abs.RSession }
RSession : Term OptRepl { Ling.Abs.Repl $1 $2 }

ListRSession :: { [Ling.Abs.RSession] }
ListRSession
  : {- empty -} { [] }
  | RSession { (:[]) $1 }
  | RSession ',' ListRSession { (:) $1 $3 }

OptRepl :: { Ling.Abs.OptRepl }
OptRepl
  : {- empty -} { Ling.Abs.One } | '^' ATerm { Ling.Abs.Some $2 }

CSession :: { Ling.Abs.CSession }
CSession
  : '.' Term1 { Ling.Abs.Cont $2 } | {- empty -} { Ling.Abs.Done }

NewSig :: { Ling.Abs.NewSig }
NewSig
  : {- empty -} { Ling.Abs.NoNewSig }
  | ':*' Term { Ling.Abs.NewTypeSig $2 }
  | ':' Term { Ling.Abs.NewSessSig $2 }

NewPatt :: { Ling.Abs.NewPatt }
NewPatt
  : '[' ListCPatt ']' { Ling.Abs.TenNewPatt $2 }
  | '[:' ListCPatt ':]' { Ling.Abs.SeqNewPatt $2 }
  | '(' Name NewSig ')' { Ling.Abs.CntNewPatt $2 $3 }

NewAlloc :: { Ling.Abs.NewAlloc }
NewAlloc
  : 'new' NewPatt { Ling.Abs.New $2 }
  | 'new/' '(' Term OptSig ')' NewPatt { Ling.Abs.NewSAnn $3 $4 $6 }
  | NewName NewPatt { Ling.Abs.NewNAnn $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}
