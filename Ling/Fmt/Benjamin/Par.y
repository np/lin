-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Ling.Fmt.Benjamin.Par
  ( happyError
  , myLexer
  , pProgram
  , pDec
  , pAssertion
  , pConName
  , pListConName
  , pOptSig
  , pListDec
  , pVarDec
  , pChanDec
  , pListChanDec
  , pBranch
  , pListBranch
  , pLiteral
  , pATerm
  , pListATerm
  , pTerm3
  , pTerm2
  , pTerm1
  , pTerm
  , pProc1
  , pProc
  , pListProc
  , pReplKind
  , pWithIndex
  , pAct
  , pASession
  , pOptAs
  , pOptSplit
  , pTopCPatt
  , pCPatt
  , pListCPatt
  , pOptSession
  , pRSession
  , pListRSession
  , pOptRepl
  , pCSession
  , pAllocTerm
  , pListAllocTerm
  , pNewSig
  , pNewPatt
  , pNewAlloc
  ) where

import Prelude

import qualified Ling.Fmt.Benjamin.Abs
import Ling.Fmt.Benjamin.Lex

}

%name pProgram Program
%name pDec Dec
%name pAssertion Assertion
%name pConName ConName
%name pListConName ListConName
%name pOptSig OptSig
%name pListDec ListDec
%name pVarDec VarDec
%name pChanDec ChanDec
%name pListChanDec ListChanDec
%name pBranch Branch
%name pListBranch ListBranch
%name pLiteral Literal
%name pATerm ATerm
%name pListATerm ListATerm
%name pTerm3 Term3
%name pTerm2 Term2
%name pTerm1 Term1
%name pTerm Term
%name pProc1 Proc1
%name pProc Proc
%name pListProc ListProc
%name pReplKind ReplKind
%name pWithIndex WithIndex
%name pAct Act
%name pASession ASession
%name pOptAs OptAs
%name pOptSplit OptSplit
%name pTopCPatt TopCPatt
%name pCPatt CPatt
%name pListCPatt ListCPatt
%name pOptSession OptSession
%name pRSession RSession
%name pListRSession ListRSession
%name pOptRepl OptRepl
%name pCSession CSession
%name pAllocTerm AllocTerm
%name pListAllocTerm ListAllocTerm
%name pNewSig NewSig
%name pNewPatt NewPatt
%name pNewAlloc NewAlloc
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'        { PT _ (TS _ 1)      }
  '('        { PT _ (TS _ 2)      }
  ')'        { PT _ (TS _ 3)      }
  '**'       { PT _ (TS _ 4)      }
  ','        { PT _ (TS _ 5)      }
  '->'       { PT _ (TS _ 6)      }
  '-o'       { PT _ (TS _ 7)      }
  '.'        { PT _ (TS _ 8)      }
  ':'        { PT _ (TS _ 9)      }
  ':*'       { PT _ (TS _ 10)     }
  ':]'       { PT _ (TS _ 11)     }
  ';'        { PT _ (TS _ 12)     }
  '<'        { PT _ (TS _ 13)     }
  '<-'       { PT _ (TS _ 14)     }
  '<='       { PT _ (TS _ 15)     }
  '='        { PT _ (TS _ 16)     }
  '>'        { PT _ (TS _ 17)     }
  '?'        { PT _ (TS _ 18)     }
  '@'        { PT _ (TS _ 19)     }
  'Type'     { PT _ (TS _ 20)     }
  '['        { PT _ (TS _ 21)     }
  '[:'       { PT _ (TS _ 22)     }
  '\\'       { PT _ (TS _ 23)     }
  ']'        { PT _ (TS _ 24)     }
  '^'        { PT _ (TS _ 25)     }
  '`'        { PT _ (TS _ 26)     }
  'as'       { PT _ (TS _ 27)     }
  'assert'   { PT _ (TS _ 28)     }
  'case'     { PT _ (TS _ 29)     }
  'data'     { PT _ (TS _ 30)     }
  'end'      { PT _ (TS _ 31)     }
  'fwd'      { PT _ (TS _ 32)     }
  'in'       { PT _ (TS _ 33)     }
  'let'      { PT _ (TS _ 34)     }
  'new'      { PT _ (TS _ 35)     }
  'new/'     { PT _ (TS _ 36)     }
  'of'       { PT _ (TS _ 37)     }
  'parallel' { PT _ (TS _ 38)     }
  'proc'     { PT _ (TS _ 39)     }
  'recv'     { PT _ (TS _ 40)     }
  'send'     { PT _ (TS _ 41)     }
  'sequence' { PT _ (TS _ 42)     }
  'slice'    { PT _ (TS _ 43)     }
  'split'    { PT _ (TS _ 44)     }
  'with'     { PT _ (TS _ 45)     }
  '{'        { PT _ (TS _ 46)     }
  '|'        { PT _ (TS _ 47)     }
  '}'        { PT _ (TS _ 48)     }
  '~'        { PT _ (TS _ 49)     }
  L_charac   { PT _ (TC $$)       }
  L_doubl    { PT _ (TD $$)       }
  L_integ    { PT _ (TI $$)       }
  L_quoted   { PT _ (TL $$)       }
  L_Name     { PT _ (T_Name $$)   }
  L_OpName   { PT _ (T_OpName $$) }

%%

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Name :: { Ling.Fmt.Benjamin.Abs.Name }
Name  : L_Name { Ling.Fmt.Benjamin.Abs.Name $1 }

OpName :: { Ling.Fmt.Benjamin.Abs.OpName }
OpName  : L_OpName { Ling.Fmt.Benjamin.Abs.OpName $1 }

Program :: { Ling.Fmt.Benjamin.Abs.Program }
Program : ListDec { Ling.Fmt.Benjamin.Abs.Prg $1 }

Dec :: { Ling.Fmt.Benjamin.Abs.Dec }
Dec
  : Name OptSig '=' Term { Ling.Fmt.Benjamin.Abs.DDef $1 $2 $4 }
  | Name ':' Term { Ling.Fmt.Benjamin.Abs.DSig $1 $3 }
  | 'data' Name '=' ListConName { Ling.Fmt.Benjamin.Abs.DDat $2 $4 }
  | 'assert' Assertion { Ling.Fmt.Benjamin.Abs.DAsr $2 }

Assertion :: { Ling.Fmt.Benjamin.Abs.Assertion }
Assertion
  : Term '=' Term OptSig { Ling.Fmt.Benjamin.Abs.AEq $1 $3 $4 }

ConName :: { Ling.Fmt.Benjamin.Abs.ConName }
ConName : '`' Name { Ling.Fmt.Benjamin.Abs.CN $2 }

ListConName :: { [Ling.Fmt.Benjamin.Abs.ConName] }
ListConName
  : {- empty -} { [] }
  | ConName { (:[]) $1 }
  | ConName '|' ListConName { (:) $1 $3 }

OptSig :: { Ling.Fmt.Benjamin.Abs.OptSig }
OptSig
  : {- empty -} { Ling.Fmt.Benjamin.Abs.NoSig }
  | ':' Term { Ling.Fmt.Benjamin.Abs.SoSig $2 }

ListDec :: { [Ling.Fmt.Benjamin.Abs.Dec] }
ListDec
  : {- empty -} { [] }
  | Dec { (:[]) $1 }
  | Dec ',' ListDec { (:) $1 $3 }

VarDec :: { Ling.Fmt.Benjamin.Abs.VarDec }
VarDec : '(' Name OptSig ')' { Ling.Fmt.Benjamin.Abs.VD $2 $3 }

ChanDec :: { Ling.Fmt.Benjamin.Abs.ChanDec }
ChanDec
  : Name OptRepl OptSession { Ling.Fmt.Benjamin.Abs.CD $1 $2 $3 }

ListChanDec :: { [Ling.Fmt.Benjamin.Abs.ChanDec] }
ListChanDec
  : {- empty -} { [] }
  | ChanDec { (:[]) $1 }
  | ChanDec ',' ListChanDec { (:) $1 $3 }

Branch :: { Ling.Fmt.Benjamin.Abs.Branch }
Branch : ConName '->' Term { Ling.Fmt.Benjamin.Abs.Br $1 $3 }

ListBranch :: { [Ling.Fmt.Benjamin.Abs.Branch] }
ListBranch
  : {- empty -} { [] }
  | Branch { (:[]) $1 }
  | Branch ',' ListBranch { (:) $1 $3 }

Literal :: { Ling.Fmt.Benjamin.Abs.Literal }
Literal
  : Integer { Ling.Fmt.Benjamin.Abs.LInteger $1 }
  | Double { Ling.Fmt.Benjamin.Abs.LDouble $1 }
  | String { Ling.Fmt.Benjamin.Abs.LString $1 }
  | Char { Ling.Fmt.Benjamin.Abs.LChar $1 }

ATerm :: { Ling.Fmt.Benjamin.Abs.ATerm }
ATerm
  : Name { Ling.Fmt.Benjamin.Abs.Var $1 }
  | OpName { Ling.Fmt.Benjamin.Abs.Op $1 }
  | Literal { Ling.Fmt.Benjamin.Abs.Lit $1 }
  | ConName { Ling.Fmt.Benjamin.Abs.Con $1 }
  | 'Type' { Ling.Fmt.Benjamin.Abs.TTyp }
  | '<' ListRSession '>' { Ling.Fmt.Benjamin.Abs.TProto $2 }
  | '(' Term OptSig ')' { Ling.Fmt.Benjamin.Abs.Paren $2 $3 }
  | 'end' { Ling.Fmt.Benjamin.Abs.End }
  | '{' ListRSession '}' { Ling.Fmt.Benjamin.Abs.Par $2 }
  | '[' ListRSession ']' { Ling.Fmt.Benjamin.Abs.Ten $2 }
  | '[:' ListRSession ':]' { Ling.Fmt.Benjamin.Abs.Seq $2 }

ListATerm :: { [Ling.Fmt.Benjamin.Abs.ATerm] }
ListATerm : {- empty -} { [] } | ATerm ListATerm { (:) $1 $2 }

Term3 :: { Ling.Fmt.Benjamin.Abs.Term }
Term3 : ATerm ListATerm { Ling.Fmt.Benjamin.Abs.RawApp $1 $2 }

Term2 :: { Ling.Fmt.Benjamin.Abs.Term }
Term2
  : 'case' Term 'of' '{' ListBranch '}' { Ling.Fmt.Benjamin.Abs.Case $2 $5 }
  | '!' Term3 CSession { Ling.Fmt.Benjamin.Abs.Snd $2 $3 }
  | '?' Term3 CSession { Ling.Fmt.Benjamin.Abs.Rcv $2 $3 }
  | '~' Term2 { Ling.Fmt.Benjamin.Abs.Dual $2 }
  | '<-' Name { Ling.Fmt.Benjamin.Abs.TRecv $2 }
  | Term3 { $1 }

Term1 :: { Ling.Fmt.Benjamin.Abs.Term }
Term1
  : Term2 '-o' Term1 { Ling.Fmt.Benjamin.Abs.Loli $1 $3 }
  | Term2 '->' Term1 { Ling.Fmt.Benjamin.Abs.TFun $1 $3 }
  | Term2 '**' Term1 { Ling.Fmt.Benjamin.Abs.TSig $1 $3 }
  | 'let' Name OptSig '=' Term 'in' Term { Ling.Fmt.Benjamin.Abs.Let $2 $3 $5 $7 }
  | Term2 { $1 }

Term :: { Ling.Fmt.Benjamin.Abs.Term }
Term
  : '\\' Term2 '->' Term { Ling.Fmt.Benjamin.Abs.Lam $2 $4 }
  | 'proc' '(' ListChanDec ')' Proc { Ling.Fmt.Benjamin.Abs.TProc $3 $5 }
  | Term1 { $1 }

Proc1 :: { Ling.Fmt.Benjamin.Abs.Proc }
Proc1
  : Act { Ling.Fmt.Benjamin.Abs.PAct $1 }
  | '(' ListProc ')' { Ling.Fmt.Benjamin.Abs.PPrll $2 }
  | ReplKind '^' ATerm WithIndex Proc1 { Ling.Fmt.Benjamin.Abs.PRepl $1 $3 $4 $5 }

Proc :: { Ling.Fmt.Benjamin.Abs.Proc }
Proc
  : Proc1 Proc { Ling.Fmt.Benjamin.Abs.PNxt $1 $2 }
  | Proc1 '.' Proc { Ling.Fmt.Benjamin.Abs.PDot $1 $3 }
  | Proc1 ';' Proc { Ling.Fmt.Benjamin.Abs.PSem $1 $3 }
  | 'slice' '(' ListChanDec ')' ATerm 'as' Name Proc { Ling.Fmt.Benjamin.Abs.NewSlice $3 $5 $7 $8 }
  | Proc1 { $1 }

ListProc :: { [Ling.Fmt.Benjamin.Abs.Proc] }
ListProc
  : {- empty -} { [] }
  | Proc { (:[]) $1 }
  | Proc '|' ListProc { (:) $1 $3 }

ReplKind :: { Ling.Fmt.Benjamin.Abs.ReplKind }
ReplKind
  : 'sequence' { Ling.Fmt.Benjamin.Abs.ReplSeq }
  | 'parallel' { Ling.Fmt.Benjamin.Abs.ReplPar }

WithIndex :: { Ling.Fmt.Benjamin.Abs.WithIndex }
WithIndex
  : {- empty -} { Ling.Fmt.Benjamin.Abs.NoIndex }
  | 'with' Name { Ling.Fmt.Benjamin.Abs.SoIndex $2 }

Act :: { Ling.Fmt.Benjamin.Abs.Act }
Act
  : NewAlloc { Ling.Fmt.Benjamin.Abs.Nu $1 }
  | OptSplit '{' ListChanDec '}' { Ling.Fmt.Benjamin.Abs.ParSplit $1 $3 }
  | OptSplit '[' ListChanDec ']' { Ling.Fmt.Benjamin.Abs.TenSplit $1 $3 }
  | OptSplit '[:' ListChanDec ':]' { Ling.Fmt.Benjamin.Abs.SeqSplit $1 $3 }
  | 'send' Name ATerm { Ling.Fmt.Benjamin.Abs.Send $2 $3 }
  | Name OptSession '<-' ATerm { Ling.Fmt.Benjamin.Abs.NewSend $1 $2 $4 }
  | 'recv' Name VarDec { Ling.Fmt.Benjamin.Abs.Recv $2 $3 }
  | 'let' Name OptSig '<-' Name { Ling.Fmt.Benjamin.Abs.NewRecv $2 $3 $5 }
  | 'let' Name OptSig '<=' ATerm { Ling.Fmt.Benjamin.Abs.LetRecv $2 $3 $5 }
  | 'fwd' ASession '(' ListChanDec ')' { Ling.Fmt.Benjamin.Abs.Ax $2 $4 }
  | 'fwd' Integer ASession Name { Ling.Fmt.Benjamin.Abs.SplitAx $2 $3 $4 }
  | '@' ATerm TopCPatt { Ling.Fmt.Benjamin.Abs.At $2 $3 }
  | 'let' Name OptSig '=' ATerm { Ling.Fmt.Benjamin.Abs.LetA $2 $3 $5 }

ASession :: { Ling.Fmt.Benjamin.Abs.ASession }
ASession : ATerm { Ling.Fmt.Benjamin.Abs.AS $1 }

OptAs :: { Ling.Fmt.Benjamin.Abs.OptAs }
OptAs
  : {- empty -} { Ling.Fmt.Benjamin.Abs.NoAs }
  | 'as' { Ling.Fmt.Benjamin.Abs.SoAs }

OptSplit :: { Ling.Fmt.Benjamin.Abs.OptSplit }
OptSplit
  : 'split' Name OptAs { Ling.Fmt.Benjamin.Abs.SoSplit $2 $3 }
  | Name { Ling.Fmt.Benjamin.Abs.NoSplit $1 }

TopCPatt :: { Ling.Fmt.Benjamin.Abs.TopCPatt }
TopCPatt
  : '(' ListChanDec ')' { Ling.Fmt.Benjamin.Abs.OldTopPatt $2 }
  | '{' ListCPatt '}' { Ling.Fmt.Benjamin.Abs.ParTopPatt $2 }
  | '[' ListCPatt ']' { Ling.Fmt.Benjamin.Abs.TenTopPatt $2 }
  | '[:' ListCPatt ':]' { Ling.Fmt.Benjamin.Abs.SeqTopPatt $2 }

CPatt :: { Ling.Fmt.Benjamin.Abs.CPatt }
CPatt
  : ChanDec { Ling.Fmt.Benjamin.Abs.ChaPatt $1 }
  | '{' ListCPatt '}' { Ling.Fmt.Benjamin.Abs.ParPatt $2 }
  | '[' ListCPatt ']' { Ling.Fmt.Benjamin.Abs.TenPatt $2 }
  | '[:' ListCPatt ':]' { Ling.Fmt.Benjamin.Abs.SeqPatt $2 }

ListCPatt :: { [Ling.Fmt.Benjamin.Abs.CPatt] }
ListCPatt
  : {- empty -} { [] }
  | CPatt { (:[]) $1 }
  | CPatt ',' ListCPatt { (:) $1 $3 }

OptSession :: { Ling.Fmt.Benjamin.Abs.OptSession }
OptSession
  : {- empty -} { Ling.Fmt.Benjamin.Abs.NoSession }
  | ':' RSession { Ling.Fmt.Benjamin.Abs.SoSession $2 }

RSession :: { Ling.Fmt.Benjamin.Abs.RSession }
RSession : Term OptRepl { Ling.Fmt.Benjamin.Abs.Repl $1 $2 }

ListRSession :: { [Ling.Fmt.Benjamin.Abs.RSession] }
ListRSession
  : {- empty -} { [] }
  | RSession { (:[]) $1 }
  | RSession ',' ListRSession { (:) $1 $3 }

OptRepl :: { Ling.Fmt.Benjamin.Abs.OptRepl }
OptRepl
  : {- empty -} { Ling.Fmt.Benjamin.Abs.One }
  | '^' ATerm { Ling.Fmt.Benjamin.Abs.Some $2 }

CSession :: { Ling.Fmt.Benjamin.Abs.CSession }
CSession
  : '.' Term1 { Ling.Fmt.Benjamin.Abs.Cont $2 }
  | {- empty -} { Ling.Fmt.Benjamin.Abs.Done }

AllocTerm :: { Ling.Fmt.Benjamin.Abs.AllocTerm }
AllocTerm
  : Name { Ling.Fmt.Benjamin.Abs.AVar $1 }
  | Literal { Ling.Fmt.Benjamin.Abs.ALit $1 }
  | '(' Term OptSig ')' { Ling.Fmt.Benjamin.Abs.AParen $2 $3 }

ListAllocTerm :: { [Ling.Fmt.Benjamin.Abs.AllocTerm] }
ListAllocTerm
  : {- empty -} { [] } | AllocTerm ListAllocTerm { (:) $1 $2 }

NewSig :: { Ling.Fmt.Benjamin.Abs.NewSig }
NewSig
  : {- empty -} { Ling.Fmt.Benjamin.Abs.NoNewSig }
  | ':*' Term { Ling.Fmt.Benjamin.Abs.NewTypeSig $2 }
  | ':' Term { Ling.Fmt.Benjamin.Abs.NewSessSig $2 }

NewPatt :: { Ling.Fmt.Benjamin.Abs.NewPatt }
NewPatt
  : '[' ListCPatt ']' { Ling.Fmt.Benjamin.Abs.TenNewPatt $2 }
  | '[:' ListCPatt ':]' { Ling.Fmt.Benjamin.Abs.SeqNewPatt $2 }
  | '(' Name NewSig ')' { Ling.Fmt.Benjamin.Abs.CntNewPatt $2 $3 }

NewAlloc :: { Ling.Fmt.Benjamin.Abs.NewAlloc }
NewAlloc
  : 'new' '(' ListChanDec ')' { Ling.Fmt.Benjamin.Abs.OldNew $3 }
  | 'new' NewPatt { Ling.Fmt.Benjamin.Abs.New $2 }
  | 'new/' '(' Term OptSig ')' NewPatt { Ling.Fmt.Benjamin.Abs.NewSAnn $3 $4 $6 }
  | OpName ListAllocTerm NewPatt { Ling.Fmt.Benjamin.Abs.NewNAnn $1 $2 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}
